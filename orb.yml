version: 2.1
description: "A collection of CircleCI tools used by the Silta hosting infrastructure."

# CircleCI executors
executors:
  silta:
    docker:
      - image: wunderio/silta-circleci:v0.1

# CircleCI Jobs
jobs:
  drupal-validate:
    executor: <<parameters.executor>>
    parameters:
      executor:
        description: The name of custom executor to use
        type: executor
        default: silta
      drupal-root:
        type: string
        default: "."
      pre-validation:
        type: steps
        default: []
      post-validation:
        type: steps
        default: []
    working_directory: ~/project/<<parameters.drupal-root>>
    steps:
      - checkout:
          path: ~/project
      - steps: <<parameters.pre-validation>>
      - drupal-composer-install:
          install-dev-dependencies: true
      - phpcs
      - run:
          name: Silta basic checks
          command: |
            files=(
              silta/silta.yml
              silta/silta-prod.yml
              silta/nginx.Dockerfile
              silta/php.Dockerfile
              silta/shell.Dockerfile
              .dockerignore
              web/.dockerignore
            )

            for file in ${files[@]}; do
              if [ -f $file ]; then
                echo "✅ $file is present"
              else
                echo "❌ $file is missing from the repository."
                exit 1
              fi
            done

            if grep "drush.*8" composer.json; then
              echo "❌ Silta is not compatible with drush 8."
            fi

      - steps: <<parameters.post-validation>>

  drupal-build-deploy:
    executor: <<parameters.executor>>
    parameters:
      executor:
        description: The name of custom executor to use
        type: executor
        default: silta
      drupal-root:
        type: string
        default: "."
      codebase-build:
        type: steps
        default: []
      pre-release:
        description: Steps to be executed before the Helm release is created.
        type: steps
        default: []
      chart_name:
        type: string
        default: drupal
      chart_repository:
        type: string
        default: https://storage.googleapis.com/charts.wdr.io
      decrypt_files:
        type: string
        default: ""
      silta_config:
        type: string
        default: "silta/silta.yml"
      skip-deployment:
        type: boolean
        default: false
    working_directory: ~/project/<<parameters.drupal-root>>
    steps:
      - checkout:
          path: ~/project
      - steps: <<parameters.codebase-build>>
      - unless:
          condition: <<parameters.skip-deployment>>
          steps:
            - gcloud-login
            - drupal-docker-build
            - set-release-name
            - steps: <<parameters.pre-release>>
            - drupal-helm-deploy:
                chart_name: <<parameters.chart_name>>
                chart_repository: <<parameters.chart_repository>>
                decrypt_files: <<parameters.decrypt_files>>
                silta_config: <<parameters.silta_config>>

  frontend-build-deploy:
    executor: <<parameters.executor>>
    parameters:
      executor:
        description: The name of custom executor to use
        type: executor
        default: silta
      codebase-build:
        type: steps
        default: []
      chart_name:
        type: string
        default: frontend
      chart_repository:
        type: string
        default: https://storage.googleapis.com/charts.wdr.io
      silta_config:
        type: string
        default: "silta/silta.yml"
      skip-deployment:
        type: boolean
        default: false
    steps:
      - checkout

      - steps: <<parameters.codebase-build>>

      - setup_remote_docker

      - gcloud-login

      - docker-login

      - build-docker-image:
          dockerfile: silta/node.Dockerfile
          path: .
          identifier: node

      - unless:
          condition: <<parameters.skip-deployment>>
          steps:
            - set-release-name

            - helm-cleanup

            - run:
                name: Deploy helm release
                command: |
                  helm upgrade --install $RELEASE_NAME <<parameters.chart_name>> \
                    --repo "<<parameters.chart_repository>>" \
                    --set environmentName=$CIRCLE_BRANCH \
                    --set frontend.image=$DOCKER_REPO_HOST/$DOCKER_REPO_PROJ/${CIRCLE_PROJECT_REPONAME,,}-node:$node_HASH \
                    --set clusterDomain=$CLUSTER_DOMAIN \
                    --namespace=${CIRCLE_PROJECT_REPONAME,,} \
                    --values <<parameters.silta_config>>

            - helm-release-information

# CircleCI commands
commands:
  phpcs:
    steps:
      - run:
          name: phpcs validation
          command: |
            if [ -f vendor/bin/phpcs ]
            then
              vendor/bin/phpcs --config-set installed_paths vendor/drupal/coder/coder_sniffer
              vendor/bin/phpcs --standard=phpcs.xml -s --colors
            else
              phpcs --standard=phpcs.xml -s --colors
            fi

  drupal-composer-install:
    parameters:
      install-dev-dependencies:
        type: boolean
        default: false
    steps:
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "composer.lock" }}-<<parameters.install-dev-dependencies>>
            - v1-dependencies-{{ checksum "composer.lock" }}

      - when:
          condition: <<parameters.install-dev-dependencies>>
          steps:
            - run:
                name: composer install
                command: composer install -n --prefer-dist --ignore-platform-reqs --optimize-autoloader

      - unless:
          condition: <<parameters.install-dev-dependencies>>
          steps:
            - run:
                name: composer install
                command: composer install -n --prefer-dist --ignore-platform-reqs --no-dev --optimize-autoloader

      - run:
          name: Clean up vendor tests
          command: |
            for directory in vendor web/core web/*/contrib
            do
              if [ -d $directory ]
              then
                find $directory \( -name .git -o -name test -o -name tests -o -name Tests \) | xargs rm -rf
              fi
            done

      - save_cache:
          paths:
            - ./vendor
            - ./web/core
            - ./web/modules/contrib
            - ./web/themes/contrib
            - ./web/profiles/contrib
            - ./web/libraries
          key: v1-dependencies-{{ checksum "composer.lock" }}-<<parameters.install-dev-dependencies>>

  # Deprecated in favor of the yarn-install-build command, or even better switch to npm and use npm-install-build.
  yarn-install:
    parameters:
      cache-version:
        type: string
        default: "v1"
    steps:
      - restore_cache:
          keys:
            - <<parameters.cache-version>>-yarn-{{ checksum "yarn.lock" }}
            - <<parameters.cache-version>>-yarn-

      - run: yarn install

      - save_cache:
          paths:
            - node_modules
          key: <<parameters.cache-version>>-yarn-{{ checksum "yarn.lock" }}

  build-docker-image:
    parameters:
      dockerfile:
        type: string
      path:
        type: string
      identifier:
        type: string
    steps:
      - run:
          name: Build <<parameters.identifier>> docker image
          command: |
            IMAGE_URL=$DOCKER_REPO_HOST/$DOCKER_REPO_PROJ/${CIRCLE_PROJECT_REPONAME,,}-<<parameters.identifier>>

            # Only exclude files
            if [ -f <<parameters.path>>/.dockerignore ]
            then
              EXCLUDE_DOCKERIGNORE="--exclude-from=<<parameters.path>>/.dockerignore"
            fi

            # Take a hash of all files in the folder except those ignored by docker.
            # Also make sure modification time or order play no role.
            IMAGE_TAG=`tar \
              --sort=name \
              $EXCLUDE_DOCKERIGNORE \
              --exclude=vendor/composer \
              --exclude=vendor/autoload.php \
              --mtime='2000-01-01 00:00Z' \
              --clamp-mtime \
              -cf - <<parameters.path>> <<parameters.dockerfile>> | sha1sum | cut -c 1-40`

            if gcloud container images list-tags $IMAGE_URL | grep -q $IMAGE_TAG;
            then
              echo "This <<parameters.identifier>> image has already been built, the existing image from the Docker repository will be used."
            else
              docker build -t $IMAGE_URL:$IMAGE_TAG -f <<parameters.dockerfile>> <<parameters.path>>
              docker push $IMAGE_URL:$IMAGE_TAG
            fi

            # Persist the image tag so it is available during deployment.
            echo "export <<parameters.identifier>>_HASH='$IMAGE_TAG'" >> $BASH_ENV

  npm-install-build:
    parameters:
      path:
        type: string
        default: "."
      build-command:
        type: string
        default: "npm run build"
      cache-version:
        type: string
        default: "v1"
    steps:
      - restore_cache:
          keys:
            - <<parameters.cache-version>>-npm-{{ checksum "<<parameters.path>>/package-lock.json" }}
            - <<parameters.cache-version>>-npm-

      - run:
          name: Install frontend dependencies
          command: |
            cd <<parameters.path>>
            npm install

      - run:
          name: Build frontend
          command: |
            cd <<parameters.path>>
            <<parameters.build-command>>

      - save_cache:
          paths:
            - <<parameters.path>>/node_modules
          key: <<parameters.cache-version>>-npm-{{ checksum "<<parameters.path>>/package-lock.json" }}

  yarn-install-build:
    parameters:
      path:
        type: string
        default: "."
      build-command:
        type: string
        default: "yarn build"
      cache-version:
        type: string
        default: "v1"
    steps:
      - restore_cache:
          keys:
            - <<parameters.cache-version>>-yarn-{{ checksum "<<parameters.path>>/yarn.lock" }}
            - <<parameters.cache-version>>-yarn-

      - run:
          name: Install frontend dependencies
          command: |
            cd <<parameters.path>>
            yarn install

      - run:
          name: Build frontend
          command: |
            cd <<parameters.path>>
            <<parameters.build-command>>

      - save_cache:
          paths:
            - <<parameters.path>>/node_modules
          key: <<parameters.cache-version>>-yarn-{{ checksum "<<parameters.path>>/yarn.lock" }}

  docker-login:
    steps:
      - run:
          name: Login to the docker registry
          command: echo $GCLOUD_KEY_JSON | docker login -u _json_key --password-stdin https://$DOCKER_REPO_HOST

  drupal-docker-build:
    steps:
      - setup_remote_docker

      - docker-login

      - build-docker-image:
          dockerfile: silta/nginx.Dockerfile
          path: web
          identifier: nginx

      - build-docker-image:
          dockerfile: silta/php.Dockerfile
          path: "."
          identifier: php

      - build-docker-image:
          dockerfile: silta/shell.Dockerfile
          path: "."
          identifier: shell

  set-release-name:
    steps:
      - run:
          name: Set release name
          command: |
            # Release name length is 37 chars long, which leaves max 16 chars for kubernetes resource name.
            # Release name is prefixed with w because  it _HAS_ to start with alphabetic character. w 4 wunder.
            BRANCHNAME_LOWER=${CIRCLE_BRANCH,,}
            BRANCHNAME=${BRANCHNAME_LOWER//[^[:alnum:]]/-}
            BRANCHNAME_HASH=$(echo -n $BRANCHNAME | shasum -a 256 | cut -c 1-4 )
            BRANCHNAME_TRUNCATED=$(echo $BRANCHNAME | cut -c 1-15 | sed 's/^\(.*\)-$/\1/' )
            REPONAME=${CIRCLE_PROJECT_REPONAME,,}
            REPONAME_HASH=$(echo -n $REPONAME | shasum -a 256 | cut -c 1-4 )
            REPONAME_TRUNCATED=$(echo $REPONAME | cut -c 1-15 | sed 's/^\(.*\)-$/\1/' )
            # Truncate long names
            if [ ${#BRANCHNAME} -ge 20 ]; then BRANCHNAME=$BRANCHNAME_TRUNCATED-$BRANCHNAME_HASH; fi;
            if [ ${#REPONAME} -ge 20 ]; then REPONAME=$REPONAME_TRUNCATED-$REPONAME_HASH; fi;
            echo "export RELEASE_NAME='$REPONAME--$BRANCHNAME'" >> $BASH_ENV

            echo "The release name for this branch is $REPONAME--$BRANCHNAME"

  gcloud-login:
    steps:
      - run:
          name: Google Cloud login
          command: |
            # Save key, authenticate and set compute zone.
            echo $GCLOUD_KEY_JSON > ${HOME}/gcloud-service-key.json
            gcloud auth activate-service-account --key-file=${HOME}/gcloud-service-key.json --project $GCLOUD_PROJECT_NAME
            gcloud config set compute/zone $GCLOUD_COMPUTE_ZONE

            # Updates a kubeconfig file with appropriate credentials and endpoint information.
            gcloud container clusters get-credentials $GCLOUD_CLUSTER_NAME --zone $GCLOUD_COMPUTE_ZONE --project $GCLOUD_PROJECT_NAME

  helm-cleanup:
    steps:
      - run:
          name: Clean up failed Helm releases
          command: |
            if [[ "$( helm list --failed | grep $RELEASE_NAME  | cut -f2 )" -eq 1 ]]; then
              # Remove any existing post-release hook, since it's technically not part of the release.
              kubectl delete job -n ${CIRCLE_PROJECT_REPONAME,,} $RELEASE_NAME-post-release 2> /dev/null || true

              echo "Removing failed first release"
              helm delete --purge $RELEASE_NAME

              until [[ -z `kubectl get pv | grep "$RELEASE_NAME-public-files"` ]]
              do
                echo "Waiting for volumes to be deleted."
                sleep 5
              done
            fi

  helm-release-information:
    steps:
      - run:
          name: Release information
          command: |
            # Display only the part following NOTES from the helm status.
            helm status $RELEASE_NAME | sed -e '1,/NOTES/d'

  drupal-helm-deploy:
    parameters:
      chart_name:
        type: string
      chart_repository:
        type: string
      decrypt_files:
        type: string
      silta_config:
        type: string
    steps:
      - helm-cleanup
      - run:
          name: Deploy helm release
          command: |

            # Secret management
            if [[ ! -z "<<parameters.decrypt_files>>" ]]; then
              echo "Decrypting secrets"
              secrets="<<parameters.decrypt_files>>" 
              for i in ${secrets//,/}; do 
                echo $i;
                openssl enc -d -aes-256-cbc -pbkdf2 -in $i -out $i.tmp -pass pass:${SECRET_KEY};
                mv $i.tmp $i;
              done
            fi

            # Disable reference data if the required volume is not present.
            REFERENCE_VOLUME=`kubectl get pv | grep "${CIRCLE_PROJECT_REPONAME,,}\/.*-reference-data"` || true
            if [[ -z $REFERENCE_VOLUME ]] ; then
              REFERENCE_DATA_OVERRIDE="--set referenceData.skipMount=true"
            fi

            # Structure IP whitelist
            #export WHITELIST_IP_oldVpn="1.1.1.1"
            #export WHITELIST_IP_newVpn="2.2.2.2"

            #WHITELISTED_IPS=""
            #for var in `env | grep WHITELIST_IP_`; do
            #  NAME=`echo $var | cut -f 1 -d "="| sed "s/WHITELIST_IP_//"`
            #  IP=`echo $var | cut -f 2 -d "="`
            #  WHITELISTED_IPS="$WHITELISTED_IPS --set nginx.basicauth.noauthips.$NAME='$IP'"
            #done

            # echo $WHITELISTED_IPS

            helm upgrade --install $RELEASE_NAME <<parameters.chart_name>> \
              --repo "<<parameters.chart_repository>>" \
              --set environmentName=$CIRCLE_BRANCH \
              --set php.image=$DOCKER_REPO_HOST/$DOCKER_REPO_PROJ/${CIRCLE_PROJECT_REPONAME,,}-php:$php_HASH \
              --set nginx.image=$DOCKER_REPO_HOST/$DOCKER_REPO_PROJ/${CIRCLE_PROJECT_REPONAME,,}-nginx:$nginx_HASH \
              --set shell.image=$DOCKER_REPO_HOST/$DOCKER_REPO_PROJ/${CIRCLE_PROJECT_REPONAME,,}-shell:$shell_HASH \
              --set mariadb.rootUser.password=$DB_ROOT_PASS \
              --set mariadb.db.password=$DB_USER_PASS \
              --set shell.gitAuth.repositoryUrl="${CIRCLE_REPOSITORY_URL}" \
              --set shell.gitAuth.apiToken="${GITAUTH_API_TOKEN}" \
              --set clusterDomain=$CLUSTER_DOMAIN \
              $REFERENCE_DATA_OVERRIDE \
              --namespace=${CIRCLE_PROJECT_REPONAME,,} \
              --values <<parameters.silta_config>>

      - run:
          name: Deployment log
          when: always
          command: |
            kubectl logs job/${RELEASE_NAME}-post-release -n ${CIRCLE_PROJECT_REPONAME,,} -f --timestamps=true

      - helm-release-information
